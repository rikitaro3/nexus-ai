---
alwaysApply: false
---
# システム要件定義ドラフト  
（ドキュメント階層管理＋AI駆動ブレークダウン＋品質ゲート）

## 0. このドキュメントについて
本ドキュメントは、以下を対象とした要件定義ドラフトである。

- 事業戦略〜運用手順までを一貫して、辿れるように管理するドキュメント体系
- それを可視化・ナビゲーションするUI（ビューワー）
- 口頭ベースの要求から機能仕様・実装手順・テスト資産を半自動で生成していくAI連携フロー
- 生成物の品質を担保するクオリティゲート（Validation）
- それらを全体として DAG（有向非巡回グラフ）構造でつなぐ考え方

ここで定義するものは最終実装仕様ではなく、「こういう仕組みを作るべき」という設計思想と機能要求の骨子である。


---

## 1. 背景・目的

### 1.1 背景
- ソフトウェア開発には、非常に幅の広いドキュメントが存在する。
  - 例：経営・事業レベルの戦略ドキュメント
  - プロダクト戦略 / 機能仕様書
  - 詳細設計、データマイグレーション手順、リリース手順書、運用ガイド、E2Eテスト方法
- これらはすべて、本来は一本の線でつながっているべきもの。
  - 「なぜこの作業をやるのか？」と遡れば経営戦略に戻れること
  - 「この戦略はどんな落とし込みがされているのか？」と下っていけば現場の手順に降りられること
- しかし現実は、単純なディレクトリ構造やWikiの羅列だと、関係性が埋もれてしまい、リンクや背景のトレーサビリティが壊れがち。

### 1.2 目的
- ドキュメントを階層的かつ関係的（DAG的）に管理し、上位と下位のつながりを常に明示する。
- UI上で「戦略→機能→設計→作業手順→テスト運用」まで辿れるようにする。
- 口頭ベースの要求から、その要求が具体的な実装・テスト資産に落ちていくプロセスを、半自動（AI支援）で回せるようにする。
- AIが出した成果物（コードや手順書）に対し、Validation（クオリティゲート）を通して品質を担保した上で登録する。


---

## 2. 用語定義

- **上位要求（ビジネス要求 / 改善要求）**  
  ユーザーが自然言語で発する「こういうことを実現したい」「こういう問題を解決したい」。

- **対応方針ノード**  
  上位要求に対して「この方向で解決しましょう」というレベルのアプローチ案。  
  例：「品質を安定させたい」→「E2Eテスト基盤を整備するべき」。

- **タスク分解 / 具体タスク**  
  対応方針を実現するための具体的なステップや作業手順。  
  例：「テストランナー導入」「サンプルシナリオ作成」「CIでE2Eを回す設定を追加」。

- **成果物ドキュメント**  
  生成される具体アウトプット（手順書.md、運用ガイド.md、テストケース定義、コード差分案など）。

- **DAG（有向非巡回グラフ）**  
  上位要求 → 対応方針 → タスク分解結果 → 成果物ドキュメント  
  という一方向の「派生関係」「根拠関係」を表す構造。循環しない。

- **ビューワー**  
  上記のDAGをツリー的に可視化し、各ノード（ドキュメント）を閲覧・遡行・下降できるUI。

- **Validation（クオリティゲートウェイ）**  
  AI生成物（コードや手順書など）を登録・承認する前に、仕様面・形式面・技術面で自動/半自動チェックするプロセス。


---

## 3. システム全体要求

### 3.1 ドキュメント階層とトレーサビリティ
- すべてのドキュメントは、必ず上位の根拠（親ノード）を持つ。
  - 例：  
    - 事業戦略ドキュメント  
      ↓  
    - プロダクト戦略 / 機能要求定義  
      ↓  
    - 詳細設計 / テスト戦略  
      ↓  
    - 実装手順書・運用手順書・E2Eテスト手順書
- 逆方向にも辿れる必要がある。
  - 「この運用手順書は、どの設計から生まれたの？」  
  - 「この設計は、どの機能要求／どのビジネス要求から来てるの？」

#### 要件
- ドキュメント同士のリンクは「DAGのエッジ」として定義する。
- 各ドキュメントは、最低限以下のメタデータを持つこと：
  - ノードID
  - タイトル
  - 種別（例：事業戦略 / 機能仕様 / 設計 / 手順書 / テストケース定義 etc.）
  - 上位ノードID（複数可）
  - 下位ノードID（複数可）
  - ステータス（草案 / レビュー済み / 承認済み）
  - Validation通過済みフラグ（後述）

- ドキュメント本文はMarkdownなどのテキストで保持する想定。

- 各ドキュメント種別には、テンプレート（必須セクション）がある程度決まっていることが望ましい：
  - 目的 / 背景（どの上位要求から来たのか）
  - 要件・仕様 / 方針
  - 実現ステップ / 手順
  - 依存関係（他ドキュメントへのリンク）
  - 次に作るべき下位成果物の期待


### 3.2 ビューワー（GUI）要求
- 目的：人間が頭の中で全体像を保持しなくても、関係と背景を辿れるようにする。
- 一般的な「フォルダにMarkdownが並んでるだけ」では不十分。  
  理由：フォルダ階層＝実際の因果/依存関係ではないから。

#### 要件（ビューワー機能）
- DAG/ツリーをGUIで展開・折りたたみできる。
- 各ノードをクリックすると、そのドキュメント本文およびメタデータを右側などに表示できる。
- 「上位に遡る」「下位に降りる」ナビゲーションがワンクリックでできる。
- フィルタ機能：
  - 特定のビジネス要求から派生した全ノードを一覧表示。
  - ステータス（草案 / 承認済み）で絞る。
  - Validation未通過のノードだけを抽出するなど。

#### 優先度
- 本システムの第一フェーズの最優先機能はこのビューワー（閲覧・トレース可能なUI）と、ドキュメント＋リンク（DAG）の保存。


### 3.3 AI支援ブレークダウン・登録フロー
このフローは「要求 → 方針 → タスク分解 → 成果物 → 登録」を半自動化する。

#### ステップ1: 要求入力
- ユーザーが自然言語で要求を投げる。（音声・口頭イメージ）
  - 例：「品質をもっと安定させたい」
- これが「上位要求ノード」として登録される。
  - ノードIDが振られる。
  - ビューワー上でも一番上流のノードとして表示される。

#### ステップ2: 対応方針ノードの作成（軽い分解）
- システム側（あなた＋軽いAIサポート）が、その要求に対して「どう解決するべきか」という方針をまとめる。
  - 例：「E2Eテスト基盤の整備が必要」
- これが「対応方針ノード」として新規ノード化される。
- DAG上で `上位要求ノード → 対応方針ノード` のエッジが張られる。

#### ステップ3: Cursorによる重い分解・具体化
- 対応方針ノードの内容を、Cursorに投げて詳細化させる。
- Cursorに渡す入力はテンプレート化する。最低限含むべきもの：
  - ゴール（何を達成したいのか）
  - 前提条件 / 現状
  - 成功条件 / 検証基準
  - 必要な成果物一覧（どんなドキュメント・どんなコード・どんな設定ファイルを出すべきか）
  - 出力フォーマット指定（Markdown, .mdc, .kt, .yaml などフォーマットを強制）
  - リポジトリ内で新規作成/更新すべきファイルパスの一覧

- Cursorの役割：
  - タスクを手順レベルまで分解する。
  - コードや設定ファイルのドラフトを生成する。
  - セットアップ手順書（例：`e2e-setup-guide.md`）や運用ガイド（`e2e-run-ops.md`）などの文章ドラフトを生成する。
  - 必要な変更を差分（patch案）として示す。

- コスト設計として、これは全自動で常時叩かれるのではなく、人間が手動でCursorを呼ぶ運用でOK。
  - Cursorは定額なので長い思考（重い分解）はCursor側に寄せる。
  - 一方でAPI経由で無限に外部LLMを叩くようなコスト爆発は避ける。

#### ステップ4: Validation（クオリティゲート）
- Cursorから返却されたアウトプット（手順書、コード差分案、設計指針など）を、即コミットせずに検証する。
- 検証対象は大きく2つ：
  1. コード／設定変更案  
     - ビルド・Lint・静的解析で問題ないか  
     - 既存のテストやE2Eが通る見込みか  
     - アーキ・命名・セキュリティのルールに反していないか
  2. ドキュメント（手順書・運用ガイド・テストケース定義など）  
     - テンプレートの必須項目が埋まっているか  
     - 「どの上位要求から生まれたのか」が明示されているか  
     - 成功条件（期待される状態）と検証手順が書かれているか  
     - 次に誰が何をやるかが分かるか（下位成果物の定義）

- Validationを通過したものだけが「承認済みアウトプット」となる。

#### ステップ5: システムへの登録・DAG反映
- Validationを通過した成果物を、正式なドキュメントノード／作業ノードとして登録する。
- 登録時に、DAG上のひも付けを明示する：
  - 「この手順書はどの対応方針ノードにぶら下がるのか」
  - 「このテストケース群はどの機能要求から派生しているのか」
- これにより、DAGはこう辿れるようになる：
  - 上位要求（口頭インプット）
    ↓
  - 対応方針ノード（例：E2E基盤を整える）
    ↓
  - Cursorが分解した具体タスク／コード案／手順ドラフト
    ↓
  - Validation後に承認された正式ドキュメント・コード差分

- ビューワー上では、この鎖を上下に辿れる。
  - 上に遡る：「なぜこの手順書が存在するの？」→ビジネス要求まで戻れる
  - 下に降りる：「このビジネス要求はどこまで具体化・実装済み？」→運用フローやテストケースまで降りられる


### 3.4 Validation（クオリティゲートウェイ）の要件
- 目的：AIのアウトプットをそのまま信じて壊れたものを入れない。
- 要件：
  - ドキュメント側チェック
    - 必須セクションの網羅性チェック
    - 上位ノードIDの明記チェック
    - 下位成果物の定義チェック
    - ステータス（草案/承認済み）管理
  - コード側チェック
    - Lint / 型 / ビルド / CIテストなどの自動チェック
    - セキュリティや危険な処理の検出
    - 命名規約やレイヤー分割規約の違反検出（将来的にルール化）
- Validation未通過のものには「差分とコメント」を残し、Cursorに戻して修正プロンプトとして使える想定（リトライループが回る）。

- このValidation済みフラグは、ドキュメントメタデータとして保持する（ビューワーでフィルタ可能にする）。


### 3.5 優先順位（段階的スコープ）
1. **Phase 1**
   - ドキュメントをノードとして登録し、DAG（上位/下位リンク）として管理できる基盤。
   - それをツリー／グラフ的に閲覧できるビューワーUI。
2. **Phase 2**
   - ユーザーの要求入力→対応方針ノード作成→Cursor投入→成果物取得→Validation→登録 という半自動ワークフローの運用を確立。
   - Cursorへの入力テンプレート、出力テンプレートの標準化。
3. **Phase 3**
   - Validationの自動化と高度化（形式検証＋コード検証＋整合性検証）。
   - 「承認済みアウトプットのみが最終ドキュメント」として扱われるゲート運用。
4. **Phase 4**
   - リポジトリへのコミット・更新とこのドキュメント管理の連携（承認済みアウトプットをそのまま資産化）。


---

## 4. 期待される最終像（ゴールイメージ）

- あなたが「やりたいこと」「困ってること」「上げたい指標」を自然言語で話すだけで、それが上位要求ノードになる。
- システムはそれを方針に落とし、Cursorが詳細な作業ステップ・コード・手順書ドラフトを吐く。
- 生成物はValidationを通され、承認されたものだけが正式なノード（設計・手順・運用・テストケース等）としてDAGに登録される。
- ビューワー上では、最上位の事業戦略から、実際のリリース手順書やE2Eテストケースまで一直線に辿れる。
- つまり「この作業はなぜ存在するのか？」と「この戦略はどこまで具現化されているのか？」が双方向で可視化される。


---

## 5. まとめ

- このシステムは「ドキュメント倉庫」ではなく「意思決定ツリー＋証跡マップ」。
- DAGで上位／下位の関係を厳密に管理することで、戦略から現場手順までのトレーサビリティを保証する。
- ブレークダウンはAI（Cursor）を使って重い作業を代行させつつ、人間が介在してコストコントロールと方向修正を行う。
- Validation（クオリティゲートウェイ）により、AIの出力品質を統制し、信頼できる資産だけを公式ドキュメント／公式コードとして登録できる。

この方針をベースに、次ステップでは各ドキュメント種別ごとのテンプレート定義（項目スキーマ）と、Validationルールの初期版（チェックリスト）を具体化する。
