# 共通コンポーネント設計

> Breadcrumbs
> Layer: ARCH
> Upstream: docs/ARCH/index.mdc
> Downstream: N/A

## 目次

1. [設計方針](#1-設計方針)
2. [必須共通コンポーネント](#2-必須共通コンポーネント)
3. [セキュリティコンポーネント](#3-セキュリティコンポーネント)
4. [ロガーコンポーネント](#35-ロガーコンポーネント)
5. [エラーハンドラーコンポーネント](#36-エラーハンドラーコンポーネント)
6. [IPCハンドラーコンポーネント](#4-ipcハンドラーコンポーネント)
7. [型定義コンポーネント](#5-型定義コンポーネント)
8. [ディレクトリ構造](#6-ディレクトリ構造)
9. [実装計画](#7-実装計画)
10. [使用例](#8-使用例)

---

## 1. 設計方針

### 1.1 目標

- DRY原則の徹底（重複コードの排除）
- セキュリティルールの一元管理
- 型安全性の確保
- テスタビリティの向上

### 1.2 設計原則

1. **単一責任の原則**: 各コンポーネントは1つの責務に集中
2. **依存性の逆転**: 抽象化に依存、具象に依存しない
3. **開放閉鎖の原則**: 拡張に開放、修正に閉鎖
4. **DRY原則**: 同じロジックの重複を避ける

### 1.3 実装方針

- TypeScriptによる型安全性の確保
- 各コンポーネントは独立したユニットとして実装
- ユニットテスト可能な設計
- 再利用可能な関数として提供

---

## 2. 必須共通コンポーネント

### 2.1 概要

ベストプラクティスに基づき、Electronアプリケーション全体で必要な共通コンポーネントを定義します。

### 2.2 コンポーネント一覧

| コンポーネント | 優先度 | 目的 | ファイル |
|--------------|-------|------|---------|
| ロガー | 高 | ログ管理、デバッグ支援 | `logger.ts` |
| 設定管理 | 高 | 環境設定、アプリ設定 | `config.ts` |
| エラーハンドリング | 高 | 統一された例外処理 | `error-handler.ts` |
| セキュリティ | 高 | パス検証、セキュリティ制御 | `security.ts` |
| IPC通信 | 高 | IPC統一インターフェース | `ipc.ts` |
| ユーティリティ | 中 | 汎用ユーティリティ関数 | `utils.ts` |
| ステート管理 | 低 | アプリケーション状態管理 | `state.ts` |
| 国際化 | 低 | 多言語対応 | `i18n.ts` |

### 2.3 実装方針

- **高優先度コンポーネント**: まず実装し、他のコンポーネントで利用可能にする
- **中優先度コンポーネント**: 必要に応じて段階的に追加
- **低優先度コンポーネント**: 将来的な拡張として検討

### 2.4 依存関係

```
config.ts ─────────> logger.ts
    │                    │
    │                    ├─> security.ts
    │                    │      │
    │                    │      └─> ipc.ts
    │                    │           │
    └─> error-handler.ts └─────────────┘
```

---

## 3. セキュリティコンポーネント

### 3.1 ファイル: `src/main/handlers/security.ts`

#### 目的
パス検証、リポジトリルート解決、セキュリティルールの一元管理

#### 型定義

```typescript
export interface PathValidationResult {
  valid: boolean;
  repoRoot: string;
  normalized: string;
  target: string;
  error?: string;
}

export interface SecurityConfig {
  allowPaths: string[];      // 許可パス配列
  denyPaths: string[];        // 拒否パス配列
  maxPathLength: number;      // 最大パス長
}
```

#### 主要関数

##### `getRepoRoot(): string`
リポジトリのルートディレクトリを解決する

```typescript
export function getRepoRoot(): string {
  // __dirnameは'tools/nexus/dist'なので、リポジトリルートは'../../..'
  return path.resolve(__dirname, '../../..');
}
```

仕様:
- 呼び出し元の`__dirname`から相対的に解決
- 実行時ディレクトリに依存しない
- 戻り値は絶対パス

##### `validatePath(relPath: string): PathValidationResult`
相対パスを検証し、リポジトリ外アクセスを防止する

```typescript
export function validatePath(relPath: string): PathValidationResult {
  try {
    const repoRoot = getRepoRoot();
    const normalized = path.normalize(relPath);
    const target = path.resolve(repoRoot, normalized);
    
    // ディレクトリトラバーサル攻撃の防止
    if (normalized.includes('..')) {
      return {
        valid: false,
        repoRoot,
        normalized,
        target,
        error: 'ディレクトリトラバーサル攻撃を検出'
      };
    }
    
    // リポジトリ外へのアクセス防止
    if (!target.startsWith(repoRoot)) {
      return {
        valid: false,
        repoRoot,
        normalized,
        target,
        error: 'パスがリポジトリ外'
      };
    }
    
    return {
      valid: true,
      repoRoot,
      normalized,
      target
    };
  } catch (e) {
    return {
      valid: false,
      repoRoot: '',
      normalized: '',
      target: '',
      error: (e as Error).message
    };
  }
}
```

仕様:
- `..`を含むパスを拒否（ディレクトリトラバーサル攻撃対策）
- リポジトリ外へのアクセスを拒否
- エラー時は詳細な情報を含む`PathValidationResult`を返却

##### `withPathValidation<T>(handler)`
IPCハンドラーにパス検証を追加するラッパー関数

```typescript
export function withPathValidation<T>(
  handler: (event: IpcMainInvokeEvent, validatedPath: PathValidationResult) => Promise<T>
) {
  return async (event: IpcMainInvokeEvent, relPath: string): Promise<T> => {
    const validation = validatePath(relPath);
    
    if (!validation.valid) {
      console.error('[Security] Path validation failed:', validation);
      throw new Error(validation.error || 'パス検証失敗');
    }
    
    return handler(event, validation);
  };
}
```

仕様:
- IPCハンドラー関数を受け取る
- 自動的にパス検証を実施
- 検証失敗時はエラーをスロー
- 検証成功時は検証済みパス情報を渡す

---

## 3.5 ロガーコンポーネント

### 3.5.1 ファイル: `src/main/utils/logger.ts`

#### 目的
統一されたログ管理機能を提供

#### 実装

```typescript
export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error'
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  context?: Record<string, any>;
}

class Logger {
  private minLevel: LogLevel;

  constructor() {
    this.minLevel = process.env.NEXUS_DEBUG === '1' ? LogLevel.DEBUG : LogLevel.INFO;
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = [LogLevel.DEBUG, LogLevel.INFO, LogLevel.WARN, LogLevel.ERROR];
    return levels.indexOf(level) >= levels.indexOf(this.minLevel);
  }

  private log(level: LogLevel, message: string, context?: Record<string, any>): void {
    if (!this.shouldLog(level)) return;

    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context
    };

    const prefix = `[${level.toUpperCase()}]`;
    console[level === LogLevel.ERROR ? 'error' : level === LogLevel.WARN ? 'warn' : 'log'](
      prefix,
      message,
      context ? JSON.stringify(context, null, 2) : ''
    );
  }

  debug(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.DEBUG, message, context);
  }

  info(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.INFO, message, context);
  }

  warn(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.WARN, message, context);
  }

  error(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.ERROR, message, context);
  }
}

export const logger = new Logger();
```

#### 使用例

```typescript
import { logger } from '../utils/logger';

// デバッグログ
logger.debug('Parsing context map', { file: 'context.mdc' });

// 情報ログ
logger.info('Document loaded successfully', { path: 'docs/PRD/要求仕様書.mdc' });

// 警告ログ
logger.warn('Unexpected path detected', { path: '../..', normalized: '../..' });

// エラーログ
logger.error('Failed to read file', { error: err.message, path: relPath });
```

---

## 3.6 エラーハンドラーコンポーネント

### 3.6.1 ファイル: `src/main/utils/error-handler.ts`

#### 目的
統一された例外処理とエラー通知機能を提供

#### 実装

```typescript
import { logger } from './logger';

export enum ErrorType {
  VALIDATION_ERROR = 'ValidationError',
  SECURITY_ERROR = 'SecurityError',
  IPC_ERROR = 'IpcError',
  FILE_ERROR = 'FileError',
  UNKNOWN_ERROR = 'UnknownError'
}

export class AppError extends Error {
  constructor(
    public type: ErrorType,
    message: string,
    public context?: Record<string, any>
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}

export function handleError(error: unknown, context?: Record<string, any>): AppError {
  let appError: AppError;

  if (error instanceof AppError) {
    appError = error;
  } else if (error instanceof Error) {
    appError = new AppError(
      ErrorType.UNKNOWN_ERROR,
      error.message,
      { ...context, originalError: error.stack }
    );
  } else {
    appError = new AppError(
      ErrorType.UNKNOWN_ERROR,
      'Unknown error occurred',
      { context, error: String(error) }
    );
  }

  logger.error(`[${appError.type}] ${appError.message}`, appError.context);
  
  return appError;
}

export function createValidationError(message: string, context?: Record<string, any>): AppError {
  return new AppError(ErrorType.VALIDATION_ERROR, message, context);
}

export function createSecurityError(message: string, context?: Record<string, any>): AppError {
  return new AppError(ErrorType.SECURITY_ERROR, message, context);
}

export function createIpcError(message: string, context?: Record<string, any>): AppError {
  return new AppError(ErrorType.IPC_ERROR, message, context);
}

export function createFileError(message: string, context?: Record<string, any>): AppError {
  return new AppError(ErrorType.FILE_ERROR, message, context);
}
```

#### 使用例

```typescript
import { handleError, createSecurityError } from '../utils/error-handler';

// IPCハンドラーでの使用
ipcMain.handle('docs:read', async (event, relPath: string) => {
  try {
    const validation = validatePath(relPath);
    if (!validation.valid) {
      throw createSecurityError('パスがリポジトリ外', { relPath, target: validation.target });
    }
    // ...
  } catch (error) {
    return { success: false, error: handleError(error, { relPath }).message };
  }
});
```

---

## 4. IPCハンドラーコンポーネント

### 4.1 ファイル: `src/main/handlers/docs.ts`

#### 目的
Docs関連のIPCハンドラーを提供

#### 実装

```typescript
import { ipcMain } from 'electron';
import * as fs from 'fs';
import { shell } from 'electron';
import { withPathValidation } from './security';

/**
 * ファイルを読み込む
 */
ipcMain.handle('docs:read', withPathValidation(async (event, validation) => {
  const content = fs.readFileSync(validation.target, 'utf8');
  return { success: true, content };
}));

/**
 * ファイルを外部エディタで開く
 */
ipcMain.handle('docs:open', withPathValidation(async (event, validation) => {
  const result = await shell.openPath(validation.target);
  if (result) throw new Error(result);
  return { success: true };
}));
```

### 4.2 ファイル: `src/main/handlers/tasks.ts`

#### 目的
Tasks関連のIPCハンドラーを提供

#### 実装

```typescript
import { ipcMain } from 'electron';
import * as fs from 'fs';
import * as path from 'path';
import { withPathValidation } from './security';

const TASKS_FILE = path.join(__dirname, '..', '..', 'tasks.json');

/**
 * Tasksを読み込む
 */
ipcMain.handle('tasks:readJson', async () => {
  if (!fs.existsSync(TASKS_FILE)) {
    return { success: true, data: [] };
  }
  const data = JSON.parse(fs.readFileSync(TASKS_FILE, 'utf8'));
  return { success: true, data };
});

/**
 * Tasksを保存する
 */
ipcMain.handle('tasks:writeJson', async (event, data: unknown) => {
  fs.writeFileSync(TASKS_FILE, JSON.stringify(data ?? [], null, 2), 'utf8');
  return { success: true };
});

/**
 * MDCファイルに追記する
 */
ipcMain.handle('mdc:append', withPathValidation(async (event, validation, content: string) => {
  const stamp = new Date().toISOString();
  const header = `\n\n## Imported from Nexus (${stamp})\n`;
  fs.appendFileSync(validation.target, header + (content || ''), 'utf8');
  return { success: true };
}));
```

### 4.3 ファイル: `src/main/handlers/env.ts`

#### 目的
環境変数関連のIPCハンドラーを提供

#### 実装

```typescript
import { ipcMain, app } from 'electron';

ipcMain.handle('env:isDebug', async () => {
  return { success: true, isDebug: process.env.NEXUS_DEBUG === '1' || !app.isPackaged };
});
```

---

## 5. 型定義コンポーネント

### 5.1 ファイル: `src/main/types/ipc.ts`

#### 目的
IPC通信の型定義を提供

#### 実装

```typescript
import { IpcMainInvokeEvent } from 'electron';
import { PathValidationResult } from '../handlers/security';

/**
 * 統一APIレスポンス形式
 */
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

/**
 * Docs API
 */
export interface DocsAPI {
  read(relPath: string): Promise<ApiResponse<string>>;
  open(relPath: string): Promise<ApiResponse<void>>;
}

/**
 * Tasks API
 */
export interface TasksAPI {
  readJson(): Promise<ApiResponse<any>>;
  writeJson(data: any): Promise<ApiResponse<void>>;
  appendMdc(relPath: string, content: string): Promise<ApiResponse<void>>;
}

/**
 * Environment API
 */
export interface EnvAPI {
  isDebug(): Promise<ApiResponse<boolean>>;
}

/**
 * Preload API（Renderer向け）
 */
export interface PreloadAPI {
  docs: DocsAPI;
  tasks: TasksAPI;
  env: EnvAPI;
}
```

---

## 6. ディレクトリ構造

```
tools/nexus/
├── src/
│   ├── main/
│   │   ├── main.ts                      # Electronメインプロセス
│   │   ├── handlers/
│   │   │   ├── security.ts             # セキュリティ共通コンポーネント
│   │   │   ├── docs.ts                  # Docs IPCハンドラー
│   │   │   ├── tasks.ts                 # Tasks IPCハンドラー
│   │   │   └── env.ts                   # Environment IPCハンドラー
│   │   ├── utils/
│   │   │   ├── logger.ts                # ロガー
│   │   │   ├── error-handler.ts         # エラーハンドラー
│   │   │   └── config.ts                # 設定管理
│   │   └── types/
│   │       └── ipc.ts                   # IPC型定義
│   ├── preload/
│   │   └── preload.ts                   # Preloadスクリプト
│   └── renderer/                        # Rendererプロセス
│       ├── index.html
│       ├── styles/
│       ├── features/
│       └── shared/
└── dist/                                 # ビルド出力
```

### 6.1 ディレクトリの責務

| ディレクトリ | 責務 |
|-------------|------|
| `src/main/handlers/` | IPCハンドラー、セキュリティロジック |
| `src/main/utils/` | 共通ユーティリティ（ロガー、エラーハンドラー、設定管理） |
| `src/main/types/` | 型定義、インターフェース |
| `src/main/` | Electronメインプロセス |
| `src/preload/` | ContextBridge、API公開 |
| `src/renderer/` | UI、ユーザーインタラクション |

---

## 7. 実装計画

### 7.1 フェーズ1: 基盤コンポーネント

1. `src/main/types/ipc.ts`を作成
2. `src/main/handlers/security.ts`を作成
3. ユニットテストを追加

### 7.2 フェーズ2: IPCハンドラーのリファクタリング

1. `src/main/handlers/docs.ts`を作成
2. `src/main/handlers/tasks.ts`を作成
3. `src/main/handlers/env.ts`を作成
4. `main.ts`から既存コードを移行

### 7.3 フェーズ3: 統合とテスト

1. 既存のIPCハンドラーを置き換え
2. 動作確認
3. E2Eテストの更新

### 6.4 フェーズ4: ドキュメント化

1. APIドキュメントの作成
2. コードコメントの追加
3. 設計書の更新

---

## 7. 使用例

### 7.1 セキュリティコンポーネントの使用

```typescript
// src/main/handlers/docs.ts
import { withPathValidation } from './security';

ipcMain.handle('docs:read', withPathValidation(async (event, validation) => {
  // validation.targetは検証済みパス
  // validation.repoRoot、validation.normalizedも利用可能
  const content = fs.readFileSync(validation.target, 'utf8');
  return { success: true, content };
}));
```

### 8.2 型定義の使用

```typescript
// src/main/handlers/docs.ts
import { ApiResponse } from '../types/ipc';

function readFileSync(path: string): ApiResponse<string> {
  // 実装
}
```

### 8.3 エラーハンドリング

```typescript
// src/main/handlers/docs.ts
import { withPathValidation } from './security';

ipcMain.handle('docs:read', withPathValidation(async (event, validation) => {
  try {
    const content = fs.readFileSync(validation.target, 'utf8');
    return { success: true, content };
  } catch (e) {
    console.error('[docs:read] Error:', e);
    return { success: false, error: (e as Error).message };
  }
}));
```

---

関連文書:
- docs/ARCH/index.mdc: アーキテクチャ設計書一覧
- docs/ARCH/IPC設計.mdc: IPC設計
- docs/ARCH/セキュリティ設計.mdc: セキュリティ設計
- docs/ARCH/システム構成.mdc: システム構成
