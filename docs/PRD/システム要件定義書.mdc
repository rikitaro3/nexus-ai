---
title: "システム要件定義書"
layer: "PRD"
template: "prd-system-requirements"
status: "active"
upstream:
  - "docs/PRD/index.mdc"
downstream:
  - "docs/ARCH/index.mdc"
tags:
  - "system-requirements"
  - "docs-governance"
---

# システム要件定義書

> Breadcrumbs
> Layer: PRD
> Upstream: docs/PRD/index.mdc
> Downstream: docs/ARCH/index.mdc

## 目次

0. [はじめに](#0-はじめに)
1. [機能要件の技術的実現方針](#1-機能要件の技術的実現方針)
   1. [FR-01: Docs Navigator](#11-fr-01-docs-navigator)
   2. [FR-02: Tasks](#12-fr-02-tasks)
   3. [FR-03: Quality Gates](#13-fr-03-quality-gates)
      1. [DOC-01: YAMLフロントマターとBreadcrumbs整合](#131-doc-01-yamlフロントマターとbreadcrumbs整合)
      2. [DOC-02: Layer定義準拠](#132-doc-02-layer定義準拠)
      3. [DOC-03: リンクパス存在確認](#133-doc-03-リンクパス存在確認)
      4. [DOC-04: 循環参照検出](#134-doc-04-循環参照検出)
      5. [DOC-05: 章番号必須](#135-doc-05-章番号必須)
      6. [DOC-06: 目次必須](#136-doc-06-目次必須)
      7. [DOC-07: 命名規則必須](#137-doc-07-命名規則必須)
      8. [DOC-08: 内容範囲の明示必須](#138-doc-08-内容範囲の明示必須)
      9. [TC-01: テストケース命名規則準拠](#139-tc-01-テストケース命名規則準拠)
      10. [TC-02: テストケース独立性](#1310-tc-02-テストケース独立性)
      11. [TC-03: テストケースドキュメント化](#1311-tc-03-テストケースドキュメント化)
      12. [TC-04: テストデータ管理](#1312-tc-04-テストデータ管理)
   4. [FR-09: Settings](#19-fr-09-settings)
   5. [FR-04: Context切替](#14-fr-04-context切替)
   6. [FR-05: AIモデル拡張対応（将来）](#15-fr-05-aiモデル拡張対応将来)
   7. [FR-06: ドキュメントベースBI基盤（将来）](#16-fr-06-ドキュメントベースbi基盤将来)
   8. [FR-07: ルール変更の自動反映](#17-fr-07-ルール変更の自動反映)
   9. [FR-08: 次のアクション自動提案](#18-fr-08-次のアクション自動提案)
   10. [FR-10: ドキュメント生成テンプレート](#110-fr-10-ドキュメント生成テンプレート)
   11. [FR-14: FEAT横断検索・統合表示](#114-fr-14-feat横断検索統合表示)
2. [非機能要件の技術的実現方針](#2-非機能要件の技術的実現方針)
   1. [NFR-01: ローカル運用](#21-nfr-01-ローカル運用)
   2. [NFR-02: 軽量性](#22-nfr-02-軽量性)
   3. [NFR-03: 拡張性](#23-nfr-03-拡張性)
3. [技術スタック選定理由](#3-技術スタック選定理由)
   1. [Electron](#31-electron)
   2. [TypeScript](#32-typescript)
   3. [Playwright](#33-playwright)
4. [技術制約](#4-技術制約)
   1. [Electronの制約](#41-electronの制約)
   2. [ローカル完結の制約](#42-ローカル完結の制約)
   3. [セキュリティの制約](#43-セキュリティの制約)
5. [データ要件](#5-データ要件)
   1. [データモデル](#51-データモデル)
   2. [データフロー](#52-データフロー)
6. [インターフェース要件](#6-インターフェース要件)
   1. [ファイルシステムインターフェース](#61-ファイルシステムインターフェース)
   2. [IPC](#62-ipcinter-process-communication)
   3. [システムコール](#63-システムコール)
7. [運用・保守計画](#7-運用保守計画)
   1. [開発環境](#71-開発環境)
   2. [ビルド・デプロイ](#72-ビルドデプロイ)
   3. [バージョン管理](#73-バージョン管理)
   4. [障害対応](#74-障害対応)
8. [リスク管理](#8-リスク管理)
   1. [技術的リスク](#81-技術的リスク)
   2. [運用リスク](#82-運用リスク)
   3. [セキュリティリスク](#83-セキュリティリスク)

---

## 0. はじめに

このドキュメントは、PRDで定義された要求を技術的な実装要件に落とし込んだ「システム要件定義書」です。

### 0.1 文書の位置づけ

```
PRD (要求) → システム要件定義書 → ARCH (設計) → 実装
```

- PRD: 何を作るか（WHAT）
- システム要件定義書: どの技術で実現するか（HOWの要件）
- ARCH: 具体的な設計（HOWの詳細）

### 0.2 このドキュメントの目的

- PRDの機能要件を技術仕様に変換
- 技術制約の明確化
- 実装方法の方向性の決定

---

## 1. 機能要件の技術的実現方針

### 1.1 FR-01: Docs Navigator

#### 技術要件

- フレームワーク: Electron Renderer
- ビューア: HTML/CSS/JavaScript (カスタム実装)
- データソース: context.mdc（パース済み）
- 表示方法: Tree View（再帰的DOM生成）

#### 実装方針

- parseAllBreadcrumbs(): 全ドキュメントからBreadcrumbs抽出
- buildTree(): DAG構造の構築（Map<string, Node>）
- renderTreeNode(): 再帰的DOM生成

#### 制約

- パフォーマンス: 1000ドキュメント程度まで想定
- UI/UX: 展開/折りたたみ、ノードクリック

### 1.2 FR-02: Tasks

#### 技術要件

- データ形式: JSON
- ストレージ: ローカルファイル（tasks.json）
- プロンプト辞書: ローカルファイル（prompts.json）
- UI: HTML/CSS/JavaScript

#### 実装方針

- tasks.json: ローカルファイルとして永続化
- prompts.json: プロンプト辞書の一元管理
- IPC経由でMain ProcessがファイルI/O
- localStorageで一時状態管理
- 辞書の検索・挿入機能

#### 制約

- バックアップ: git pushで手動
- 同期: 単一インスタンスのみ
- 辞書形式: JSON、検索可能な構造

### 1.3 FR-03: Quality Gates

#### 技術要件

- 検証タイミング: Tree表示時 + Validateボタンクリック
- 検証項目: DOC-01〜08（ドキュメントQuality Gates）、TC-01〜04（テストケースQuality Gates）
- メタデータ: YAMLフロントマター（title/layer/upstream/downstream/template/status/tags）
- 解析方式: remark AST（unified + remark-parse + remark-frontmatter + remark-gfm）
- 結果表示: UIにアイコン + 詳細パネル

#### 実装方針

- gray-matterでフロントマターを抽出し、normalizeFrontMatterでLayer/リンク情報を正規化
- unifiedパイプライン（remark-parse/remark-frontmatter/remark-gfm）でMarkdown ASTを構築
- DocRecord(Map)としてfrontMatter・本文・AST・タイトルを保持し、全Quality Gateから参照
- detectCycles(): 循環参照検出
- renderGateResults(): 結果UI表示

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定）
- 依存パッケージ: gray-matter, unified, remark-parse, remark-frontmatter, remark-gfm, mdast-util-to-string, unist-util-visit
- フォーマット: すべてのドキュメントは`.mdc`拡張子 + YAMLフロントマター必須

### 1.3.1 DOC-01: YAMLフロントマターとBreadcrumbs整合

#### 技術要件

- 検証タイミング: Tree表示時 + Validateボタンクリック
- 検証項目: YAMLフロントマターの存在と必須キー、H1タイトルとの整合
- 結果表示: UIにアイコン + 詳細パネル

#### 実装方針

- gray-matterでフロントマターを読み込み、title/layer/upstream/downstream/templateを必須チェック
- normalizeFrontMatter()でN/Aや空文字を排除し、配列フィールドを正規化
- extractDocumentTitle()で本文のH1を抽出し、frontMatter.titleと一致確認
- legacy Breadcrumbs表記は表示維持だが、検証ソースはYAMLフロントマターに一本化

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定）
- 依存: gray-matter, normalizeFrontMatter, extractDocumentTitle
- ユーザー編集: すべてのドキュメントにフロントマターを追加する運用に変更

### 1.3.2 DOC-02: Layer定義準拠

#### 技術要件

- 検証タイミング: Tree表示時 + Validateボタンクリック
- 検証項目: フロントマター layer が定義済み8種のいずれかである
- 結果表示: UIにアイコン + 詳細パネル

#### 実装方針

- normalizeFrontMatter()でlayerを取得し、空文字の場合はDOC-02エラー
- layer値を大文字化してVALID_LAYERS配列と比較
- frontMatter由来のlayerが欠落する場合はinferLayerFromPath()で補完を試み、最終的に厳密チェック

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定）
- 依存: normalizeFrontMatter, VALID_LAYERS, inferLayerFromPath
- ドキュメント命名規則とLayer補完の整合性に依存

### 1.3.3 DOC-03: リンクパス存在確認

#### 技術要件

- 検証タイミング: Tree表示時 + Validateボタンクリック
- 検証項目: Upstream/Downstreamパスの存在
- 結果表示: UIにアイコン + 詳細パネル

#### 実装方針

- frontMatter.upstream/downstreamは正規化済みの配列として取得
- 各リンクをnodes Mapと突き合わせ、不明なパスはDOC-03エラー
- fs.accessとコンテキストマップを併用し、未登録ファイルを特定

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定）
- 精度: frontMatter配列の正規化に依存

### 1.3.4 DOC-04: 循環参照検出

#### 技術要件

- 検証タイミング: Tree表示時 + Validateボタンクリック
- 検証項目: DAG構造の循環参照検出
- 結果表示: UIにアイコン + 詳細パネル

#### 実装方針

- DAG構築: Upstream/Downstreamリンクからグラフ構築
- DFS実装: 深さ優先探索で循環検出
- 結果表示: 循環パスを可視化

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定）
- 精度: グラフアルゴリズム精度に依存

### 1.3.5 DOC-05: 章番号必須

#### 技術要件

- 検証タイミング: Tree表示時 + Validateボタンクリック
- 検証項目: 章番号の存在と連続性
- 結果表示: UIにアイコン + 詳細パネル

#### 実装方針

- collectHeadings()でAST上のheadingノードを抽出
- レベル2/3見出しに対して章番号を分解し、親子整合と連番を検証
- 想定外の章番号・欠番・不整合は即座にDOC-05エラー

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定）
- 精度: remark AST（mdast-util-to-string, unist-util-visit）による見出し抽出に依存

### 1.3.6 DOC-06: 目次必須

#### 技術要件

- 検証タイミング: Tree表示時 + Validateボタンクリック
- 検証項目: 目次ブロックの存在とリンク有効性
- 結果表示: UIにアイコン + 詳細パネル

#### 実装方針

- findSectionByHeading()で`## 目次`セクションを特定
- collectLinksFromSection()でAnchorリンクを抽出し、`#`始まりのみ許可
- collectHeadings()から生成したスラッグと比較し、未定義アンカーを検出

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定）
- 精度: remark ASTベースのリンク抽出に依存

### 1.3.7 DOC-07: 命名規則必須

#### 技術要件

- 検証タイミング: Tree表示時 + Validateボタンクリック
- 検証項目: ファイル名の規則準拠
- 結果表示: UIにアイコン + 詳細パネル

#### 実装方針

- normalizeFrontMatter()/inferLayerFromPath()で層を特定し、selectNamingPattern()を選択
- `.mdc`拡張子を標準とし、例外はARCHレイヤーの既存`.md`のみ（段階的廃止）
- index.mdcは除外しつつ、その他ファイルに命名パターン違反があればDOC-07エラー

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定）
- 精度: frontMatterのlayer値と命名規則の同期に依存
- `.md`許容は既存資産のみを対象とし、新規作成は`.mdc`に統一

### 1.3.8 DOC-08: 内容範囲の明示必須

#### 技術要件

- 検証タイミング: Tree表示時 + Validateボタンクリック
- 検証項目: 扱う内容/扱わない内容の記載
- 結果表示: UIにアイコン + 詳細パネル

#### 実装方針

- findSectionByHeading()で「扱う内容」「扱わない内容」「Scope」セクションを取得
- sectionHasListWithContent()で各セクションに実質的な箇条書きがあるかを検証
- collectListItemTexts()でScopeセクション内のキーワード（対象/除外）を確認

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定）
- 精度: ASTベースのセクション抽出に依存

### 1.3.9 TC-01: テストケース命名規則準拠

#### 技術要件

- 検証タイミング: テストケース作成時 + CI/CD
- 検証項目: ファイル名が `[分類]-[機能]-[シナリオ].spec.ts` 形式に準拠
- 結果表示: CI/CDのエラー出力

#### 実装方針

- ファイル名パターンマッチ: `/^[a-z-]+\.spec\.ts$/`
- 分類・機能・シナリオの分割検証
- CI/CDでの自動チェック

#### 制約

- パフォーマンス: テストケース数（100件想定）
- 精度: ファイル名解析精度に依存

### 1.3.10 TC-02: テストケース独立性

#### 技術要件

- 検証タイミング: テストケース実行時
- 検証項目: 他のテストケースの結果への依存がないこと
- 結果表示: CI/CDのエラー出力

#### 実装方針

- 依存関係パターン検出: `test().*.then.*test()`, `it().*.then.*it()`
- setup/teardownの適切な使用確認
- 独立性の自動検証

#### 制約

- パフォーマンス: テストケース数（100件想定）
- 精度: コード解析精度に依存

### 1.3.11 TC-03: テストケースドキュメント化

#### 技術要件

- 検証タイミング: テストケース作成時 + CI/CD
- 検証項目: テストケースに目的と期待結果のコメントが記載されていること（目標: 80%以上）
- 結果表示: CI/CDのエラー出力

#### 実装方針

- コメント検出: `/**\s*目的[\s\S]*?期待結果[\s\S]*?\*/`
- カバレッジ計算: ドキュメント化されたテスト数 / 全テスト数
- 自動検証とレポート

#### 制約

- パフォーマンス: テストケース数（100件想定）
- 精度: コメント解析精度に依存

### 1.3.12 TC-04: テストデータ管理

#### 技術要件

- 検証タイミング: テストケース作成時 + CI/CD
- 検証項目: テストデータが `fixtures/` に配置され、setup/teardownが実装されていること
- 結果表示: CI/CDのエラー出力

#### 実装方針

- fixtures ディレクトリの存在確認
- setup/teardown 関数の検出: `setup|beforeAll`, `teardown|afterAll`
- データ管理の自動検証

#### 制約

- パフォーマンス: テストケース数（100件想定）
- 精度: コード解析精度に依存

### 1.4 FR-09: Settings

#### 技術要件

- 設定タブ: UI追加
- プロジェクトルート入力: テキスト入力フィールド
- 保存機能: localStorage
- パステスト機能: ファイル存在確認

#### 実装方針

- Settingsタブをindex.htmlに追加
- IPC経由でMain Processと連携:
  - `window.settings.getProjectRoot()`: 現在のプロジェクトルート取得
  - `window.settings.setProjectRoot(root)`: プロジェクトルート設定
- `localStorage.setItem('project-root', root)`: 設定の永続化
- パステスト: 指定パス配下で特徴的なファイル（`apps/mobile/pubspec.yaml`, `docs/PRD/index.mdc`, `human_todo.mdc`）の存在確認

#### 環境変数

- `NEXUS_PROJECT_ROOT`: プロジェクトルートパスを明示的に指定
- 優先順位: 環境変数 > カスタム設定 > 自動検出 > フォールバック

#### Context File選択

- ファイル選択ダイアログ: Electron `dialog.showOpenDialog()`
- 対象: context.mdc または .md ファイル
- 保存: localStorage に絶対パスを保存
- 優先順位: カスタムパス（localStorage） > 環境変数 > 自動検出
- 実装: Settings画面から「ファイルを選択」ボタンで呼び出し

#### 制約

- 初期値: 環境変数 → 自動検出（特徴ファイル `context.mdc` で検出）
- 検証: パステストボタンで手動検証
- 反映: アプリ再起動で反映（runtimeでの反映は未実装）
- 絶対パス対応: security.ts で絶対パスを許可、ファイル存在確認

### 1.5 FR-04: Context切替

#### 技術要件

- 環境変数: NEXUS_DEBUG
- 保存場所: localStorage
- 切替方法: ページリロード

#### 実装方針

- デバッグ時のみUI表示
- localStorageで切り替え状態を保存
- ページリロードで反映

#### 制約

- ローカルでのみ有効
- 本番環境では非表示

### 1.6 FR-05: AIモデル拡張対応（将来）

#### 技術要件

- 抽象化レイヤー: AI Provider Interface
- 設定: プロバイダー選択
- コスト管理: 使用量記録

#### 実装方針（将来）

- インターフェース定義
- Cursor, Claude, GPT-4実装
- 設定ファイル（provider.json）

#### 制約（現在）

- 実装済み: なし
- 優先度: 低（Phase 2以降）

### 1.7 FR-06: ドキュメントベースBI基盤（将来）

#### 技術要件

- ダッシュボード: データ可視化
- データソース: DAG + Quality Gates結果
- エクスポート: JSON形式

#### 実装方針（将来）

- 分析エンジン追加
- Chart.js等で可視化
- 定期レポート自動生成

#### 制約（現在）

- 実装済み: なし
- 優先度: 低（Phase 3以降）

### 1.8 FR-07: ルール変更の自動反映

#### 技術要件

- 変更検出: `docs/GATES/document.mdc`の監視
- 対象判定: 全ドキュメントスキャン
- 更新方式: 自動/半自動/手動の選択
- 検証: Quality Gates再実行

#### 実装方針

- ファイルウォッチャー: `chokidar`でGATES/document.mdc監視
- 差分検出: ルール変更の有無を確認
- スキャン: 全`*.mdc`ファイルを解析
- 更新判定: 現行ルールとの準拠状況チェック
- 更新実行: 更新対象への一括適用
- ロールバック: Gitで変更の管理

#### 制約

- 実装済み: なし
- 優先度: 中（Phase 2-3）

### 1.9 FR-08: 次のアクション自動提案

#### 技術要件

- 提案エンジン: タスク分析と優先度計算
- データソース: tasks.json、DAG、context.mdc
- UI: アクションパネル表示
- 更新頻度: ステータス変更時に再計算

#### 実装方針

- 現状分析: tasks.jsonを解析してタスクの状態を分類
- 依存関係解析: DAGから実行可能タスクを特定
- 優先度アルゴリズム:
  - カテゴリ重要度（機能改善>品質改善>リリース）
  - 依存関係の深さ（下位タスクほど優先）
  - FEAT-IDの関連度
- 推奨アクション生成: 複数の候補から最適解を提案
- アクションパネル: UIに「推奨アクション」ボタン追加

#### 制約

- 実装済み: なし
- 優先度: 高（Phase 2）
- 計算処理: リアルタイムで計算（<1秒）

### 1.10 FR-10: ドキュメント生成テンプレート

#### 技術要件

- 生成方式: Node CLI `scripts/generate-doc-from-template.js`
- テンプレート形式: `docs/templates/*.yaml`（frontMatter defaults + Markdown本文）
- 出力形式: `.mdc` + YAMLフロントマター + Breadcrumbs表示ブロック
- 新規作成時は常にテンプレート適用済みの初期コンテンツを提供し、CLI/GUI/手動コピペいずれのフローでも同一レイアウトを保証する

#### 実装方針

- CLI引数でテンプレートID/出力先/title/layer/upstream/downstream/tagsを指定可能
- js-yamlでテンプレートを読み込み、defaultsとCLI上書きをマージしてfrontMatterを生成
- mergeLists()/dedupeList()で配列値を正規化し、空値・重複を排除
- テンプレート本文は`{{title}}`等のプレースホルダをfrontMatter値で展開
- GUIからの新規作成画面ではテンプレート一覧から選択し、選択テンプレートの本文を初期表示として挿入する
- 手動作成（テンプレートコピペ）向けに、`docs/templates/*.yaml`の本文をMarkdownエディタへ貼り付けるだけでBreadcrumbsや章立てが揃うよう維持する
- 既存文書は一括移行済み（frontMatterを付与し`.mdc`へ統一）。新規作成はいずれの経路でもテンプレートを起点にする

#### 制約

- 依存: js-yaml, Node.js（同梱）
- 上書き防止: 既存ファイルは`--force`指定時のみ上書き
- テンプレート保守: ルール改訂時は`docs/templates/`配下を更新し、バージョン管理で追跡

### 1.14 FR-14: FEAT横断検索・統合表示

#### 技術要件

- 検索対象: frontMatter.layer が PRD/UX/API/DATA/QA のドキュメント
- 検索方式: 全文検索（FEAT-ID文字列マッチング）
- 検索エンジン: 既存のドキュメントパース機能を活用
- 出力形式: Markdown統合テキスト
- UI配置: Docs Navigator タブ内の新規サブタブまたはモーダル
- クリップボードAPI: Electron clipboard API使用

#### 実装方針

- FEAT-ID検索機能
  - 入力: FEAT-IDフィールド（例: FEAT-0001）
  - 検索実行: 全ドキュメントを対象にFEAT-ID文字列を検索
  - フィルタ: frontMatter.layer が PRD/UX/API/DATA/QA のドキュメントのみ対象
  - セクション抽出: FEAT-IDが含まれる見出し・段落・表を抽出

- 統合表示生成
  - レイヤー別にセクション整理:
    - PRD: 機能要件・ビジネス要求
    - UX: 画面仕様・ユーザーフロー
    - API: APIエンドポイント・インターフェース仕様
    - DATA: データモデル・スキーマ定義
    - QA: テストケース・検証項目
  - 各セクションにドキュメント名・パス・該当箇所を明記
  - Markdown形式で統合（見出しレベルを調整）

- コピー機能
  - 「すべてコピー」ボタン: 統合テキスト全体をクリップボードにコピー
  - Electron clipboard API: `clipboard.writeText()`使用
  - コピー完了通知: トースト表示（2秒間）

- UI設計
  - FEAT-ID入力フィールド
    - プレースホルダー: "FEAT-0001"
    - オートコンプリート: 既存のFEAT-IDリストから候補表示（将来拡張）
  - 検索ボタン: クリックで検索実行
  - 結果表示パネル:
    - レイヤー別のタブ表示
    - 各セクションは折りたたみ可能
    - 元ドキュメントへのリンク（window.docs.open()経由）
  - コピーボタン: 結果表示パネル上部に配置

#### データフロー

1. ユーザーがFEAT-IDを入力
2. 検索実行ボタンクリック
3. IPC経由でMain Processに検索依頼
4. Main Processが全ドキュメントをスキャン
   - gray-matterでfrontMatterを抽出
   - layer が PRD/UX/API/DATA/QA のみフィルタ
   - ドキュメント本文からFEAT-IDを全文検索
   - 該当セクションを抽出
5. 結果をRenderer Processに返却
6. レイヤー別に整理してUI表示
7. ユーザーが「すべてコピー」クリック
8. 統合テキストをクリップボードにコピー
9. トースト通知表示

#### 制約

- パフォーマンス: 全ドキュメントスキャン（1000件想定、<3秒）
- 精度: FEAT-ID文字列の完全一致検索（部分一致は対象外）
- 依存: 既存のドキュメントパース機能（gray-matter, remark）
- オートコンプリート: Phase 2以降で実装（初期版は手動入力）
- 実装済み: なし
- 優先度: 中（Phase 2-3）

---

## 2. 非機能要件の技術的実現方針

### 2.1 NFR-01: ローカル運用

#### 技術要件

- 外部API: 不使用
- データソース: ローカルファイル
- ネットワーク: 不要

#### 実装方針

- Node.js fsモジュールでファイルI/O
- 外部HTTP呼び出しなし
- Electron標準機能のみ使用

### 2.2 NFR-02: 軽量性

#### 技術要件

- 起動時間: <3秒
- メモリ使用: <200MB
- ビルドサイズ: 最小限

#### 実装方針

- Electron軽量設定
- TypeScriptコンパイル最適化
- 不要な依存関係を削除

### 2.3 NFR-03: 拡張性

#### 技術要件

- プラグインアーキテクチャ
- 設定ファイルベース
- モジュール化

#### 実装方針（将来）

- プラグインローダー
- 設定ファイル（.nexus/config.json）
- インターフェース定義

---

## 3. 技術スタック選定理由

### 3.1 Electron

理由:
- デスクトップアプリとして完結
- Node.jsアクセス可能
- クロスプラットフォーム

### 3.2 TypeScript

理由:
- 型安全性
- 事前エラー検出
- リファクタリング容易

### 3.3 Playwright

理由:
- E2Eテスト自動化
- CDP経由での操作
- スクリーンショット取得

---

## 4. 技術制約

### 4.1 Electronの制約

- ブラウザ機能の制限
- メモリ使用量
- ファイルアクセス権限

### 4.2 ローカル完結の制約

- 外部API利用不可
- クラウド連携不可
- リアルタイム同期不可

### 4.3 セキュリティの制約

- contextIsolation必須
- nodeIntegration無効化
- リポジトリ外アクセス禁止

---

## 5. データ要件

### 5.1 データモデル

#### ドキュメントメタデータ（Breadcrumbs）

- フォーマット: Markdown（.mdc）
- 構造:
  - Layer: 8種類（STRATEGY, PRD, UX, API, DATA, ARCH, DEVELOPMENT, QA）
  - Upstream: 上位ドキュメントのパス（カンマ区切り）
  - Downstream: 下位ドキュメントのパス（カンマ区切り）
- 保存場所: 各ドキュメントファイル内

#### Tasks（tasks.json）

- フォーマット: JSON
- スキーマ: id, title, category, priority, status, featId, notes, breakdownPrompt, breakdownStatus, lastBreakdownAt, links
- 保存場所: tasks.json

#### プロンプト辞書（prompts.json）

- フォーマット: JSON
- 構造: 再利用可能なプロンプトパーツ
- 保存場所: prompts.json（予定）

### 5.2 データフロー

- context.mdc → Docs Navigator（解析・表示）
- tasks.json ↔ Tasks UI（読み書き）
- Breadcrumbs → DAG構築（Tree表示）
- Quality Gates結果 → UI表示・出力

---

## 6. インターフェース要件

### 6.1 ファイルシステムインターフェース

- 読み込み: .mdcファイル、tasks.json、prompts.json
- 書き込み: tasks.json、prompts.json
- パス解決: リポジトリルートからの相対パス

### 6.2 IPC（Inter-Process Communication）

- Main Process ↔ Renderer Process
- API: window.docs.read(), window.docs.open()
- API: window.tasks.readJson(), window.tasks.writeJson()
- API: window.settings.getProjectRoot(), window.settings.setProjectRoot()

### 6.3 システムコール

- fs.readFileSync(): ファイル読み込み
- fs.writeFileSync(): ファイル書き込み

---

## 7. 運用・保守計画

### 7.1 開発環境

- ローカル完結（Electron開発モード）
- デバッグツール: DevTools（自動起動）
- コンテキスト切替: Repo / Nexus（デバッグ時のみ）

### 7.2 ビルド・デプロイ

- ビルド: `npm run build`（TypeScript → dist/）
- 実行: `npm start`（開発モード）
- リリース: Electronパッケージング（予定）

### 7.3 バージョン管理

- Gitで管理
- 変更履歴: commit messageで記録
- バックアップ: git pushで手動

### 7.4 障害対応

- エラー監視: console.log, DevTools
- ロールバック: Gitで復元
- データ復旧: tasks.jsonをgit checkout

---

## 8. リスク管理

### 8.1 技術的リスク

- Electronメモリ使用量増加
  - 対策: 仮想スクロール、遅延読み込み
- TypeScriptコンパイルエラー
  - 対策: 事前チェック、型定義の整備

### 8.2 運用リスク

- tasks.jsonの破損
  - 対策: Gitでバックアップ
- ドキュメントの不整合
  - 対策: Quality Gatesで自動検証

### 8.3 セキュリティリスク

- リポジトリ外アクセス
  - 対策: パス検証の実装
- 不正なファイルI/O
  - 対策: IPCで制限、contextIsolation

---

## 次のステップ

このシステム要件定義書を元に、詳細なアーキテクチャ設計（ARCH/システム構成.mdc等）に進みます。

関連文書:
- PRD/PRD_Requirements.mdc: 要件定義
- ARCH/システム概要.mdc: アーキテクチャ概要
- ARCH/システム構成.mdc: システム構成
