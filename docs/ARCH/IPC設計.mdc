---
title: "IPC設計"
layer: "ARCH"
template: "legacy-import"
upstream:
  - "docs/ARCH/index.mdc"
downstream:
  - "docs/DEVELOPMENT/index.mdc"
tags: []
---

# IPC設計

> Breadcrumbs
> Layer: ARCH
> Upstream: docs/ARCH/index.mdc
> Downstream: docs/DEVELOPMENT/index.mdc

## 目的
Electron Main/Renderer間のIPC契約をTypeScript実装（`src/preload/preload.ts`, `src/main/main.ts`, `src/main/handlers/security.ts`）に基づき定義し、ハンドラー責務とレスポンス形式を明確化します。

## 1. アーキテクチャ
```
Renderer (Vanilla JS) ──invoke──▶ Preload (contextBridge) ──invoke──▶ Main (ipcMain.handle)
      ▲                         │                                  │
      │                         └───────── event (rulesWatcher) ◀──┘
```
- Rendererは `window.<domain>` 名前空間に公開された関数のみ利用
- Preloadは型ガードとEnvelope変換を担当
- MainはファイルI/O・Quality Gates実行・セキュリティ検証を担当

## 2. API一覧
### 2.1 docs
| IPC Channel | Preload API | 引数 | 戻り値 |
|-------------|-------------|------|--------|
| `docs:read` | `window.docs.read(relPath)` | 相対/絶対パス | `{ success: boolean, content?: string, error?: string }` |
| `docs:open` | `window.docs.open(relPath)` | ファイルパス | `{ success: boolean, error?: string }` （外部エディタで開く） |

### 2.2 tasks
| Channel | Preload API | 説明 |
|---------|-------------|------|
| `tasks:readJson` | `window.tasks.readJson()` | `tasks.json` を読み取り `{ success, data }` |
| `tasks:writeJson` | `window.tasks.writeJson(data)` | `tasks.json` を保存 |
| `mdc:append` | `window.tasks.appendMdc(relPath, content)` | ドキュメント末尾へ追記（検証済みパスのみ） |
| `tasks:recordRecommendationSelection` | `window.tasks.recordRecommendationSelection(payload)` | 推奨タスク選択履歴を保存 |
| `tasks:readRecommendationHistory` | `window.tasks.readRecommendationHistory()` | 推奨履歴を取得 |

### 2.3 prompts
| Channel | Preload API | 説明 |
|---------|-------------|------|
| `prompts:readJson` | `window.prompts.readJson()` | `prompts.json` を読み取り |
| `prompts:writeJson` | `window.prompts.writeJson(data)` | `prompts.json` を保存 |

### 2.4 settings
| Channel | Preload API | 説明 |
|---------|-------------|------|
| `settings:getProjectRoot` | `window.settings.getProjectRoot()` | `{ root }` を返却 |
| `settings:setProjectRoot` | `window.settings.setProjectRoot(root)` | カスタムルートを設定し`setCustomProjectRoot`を更新 |
| `settings:testProjectRoot` | `window.settings.testProjectRoot(root)` | ルートアクセス可否を検証 |
| `settings:getAiProvider` | `window.settings.getAiProvider()` | `{ providerId }` を返却 |
| `settings:setAiProvider` | `window.settings.setAiProvider(providerId)` | 選択プロバイダーを永続化 |

### 2.5 env/dialog
| Channel | Preload API | 説明 |
|---------|-------------|------|
| `env:isDebug` | `window.env.isDebug()` | `{ success, isDebug }` |
| `dialog:selectContextFile` | `window.dialog.selectContextFile()` | OSファイルダイアログでContextファイルを選択 |

### 2.6 rules watcher
| Channel | Preload API | 説明 |
|---------|-------------|------|
| `rules:getLatestState` | `window.rulesWatcher.getState()` | `{ success, event?, error? }` (`RulesWatcherEventEnvelope`) |
| `rules:revalidate` | `window.rulesWatcher.revalidate(mode)` | Quality Gates再実行（`mode = 'manual' | 'bulk'`） |
| `rules:scanImpacts` | `window.rulesWatcher.scan()` | 差分無しで影響スキャンのみ |
| `rules:listLogs` | `window.rulesWatcher.listLogs()` | `{ success, logs?, error? }` |
| `rules:setContext` | `window.rulesWatcher.setContextPath(contextPath)` | Quality Gatesのコンテキストファイルを更新 |
| イベント | `window.rulesWatcher.onEvent(callback)` | `rules:watcher:event` を購読し `RulesWatcherEvent` を受信 |

## 3. ハンドラー実装ガイドライン
1. **パス検証の必須化**
   - `withPathValidation(async (_event, validation) => { ... })` を使用
   - 例外時は `createSecurityError()` を投げ、Rendererへ `{ success: false, error }`
2. **レスポンス形式**
   - 成功: `{ success: true, data? }`
   - 失敗: `{ success: false, error: string }`
   - `rules:*` 系は `{ success: boolean, event?, logs?, error? }`
3. **ログ出力**
   - 成功/失敗とも `logger` で構造化ログを残す
   - センシティブ情報（パス等）は `path.relative(repoRoot, target)` で短縮
4. **エラー隠蔽禁止**
   - 原因特定用に `error.message` をRendererへ返却
   - stackはMainのログみに記録
5. **非同期処理**
   - すべてPromiseベース。`await`で例外処理を統一

## 4. Rules Watcher IPCフロー
```
Renderer (Docs Navigator)
  ├─ revalidate('manual')
  │    │
  │    └─▶ ipcMain 'rules:revalidate'
  │          ├─ RulesWatcherController.revalidate()
  │          └─ 戻り値 { success, event }
  └─ onEvent(updatePipelineView)
       ▲
       └─ preload: ipcRenderer.on('rules:watcher:event')
```
- `getState()` → 即時スナップショット取得
- `onEvent()` → 監視イベントをPush
- RendererはEnvelopeの`success`を必ず確認し、失敗時はUIでエラー表示

## 5. セキュリティ考慮事項
- Preloadで公開していないIPCをRendererから呼び出さない（`contextIsolation`で保護）
- `window.rulesWatcher.setContextPath()` は再度 `validatePath()` を通過
- `mdc:append` は `validatePath` + 追記ヘッダ (`## Imported from Nexus (timestamp)`) を付与し、任意書き換えを防止

## 6. テスト戦略
- 単体テスト: `src/main/watchers/__tests__/rules-watcher.test.ts`
- 統合テスト: `test/integration/*.spec.ts` がIPCレスポンスの整合性を検証
- E2E: PlaywrightでRenderer経由のIPC呼び出しを網羅

## 7. 関連文書
- [セキュリティ設計.mdc](セキュリティ設計.mdc)
- [QualityGatesパイプライン詳細設計.mdc](../QA/QualityGatesパイプライン詳細設計.mdc)
- [Rendererドメインサービス設計.mdc](../DEVELOPMENT/Rendererドメインサービス設計.mdc)
