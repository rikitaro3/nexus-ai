# セキュリティ設計

> Breadcrumbs
> Layer: ARCH
> Upstream: docs/ARCH/index.mdc
> Downstream: docs/ARCH/IPC設計.mdc

## 目的
ElectronベースのNexusにおけるMain/Renderer間の境界管理、ファイルアクセス検証、プロジェクトルート切替時の安全設計を最新実装 (`src/main/handlers/security.ts`, `src/preload/preload.ts`) に合わせて整理します。

## 1. セキュリティポリシー
- `contextIsolation: true` / `nodeIntegration: false`
- Rendererは `contextBridge` が公開するAPIのみ利用可能
- IPCレスポンスは `{ success: boolean, data?, error? }` フォーマットに統一
- すべてのファイル操作は `validatePath()` を経由し、リポジトリ外アクセスを遮断

## 2. プロジェクトルート解決
`src/main/handlers/security.ts` では以下の優先度でプロジェクトルートを決定します。
1. `process.env.NEXUS_PROJECT_ROOT`
2. Settings画面から設定されたカスタムルート (`setCustomProjectRoot`)
3. Mainプロセス起動時に検出した `context.mdc` のルート (`setGlobalProjectRoot`)
4. フォールバック: `__dirname` から最大4階層上を探索

```ts
export function getRepoRoot(): string {
  if (process.env.NEXUS_PROJECT_ROOT) return process.env.NEXUS_PROJECT_ROOT;
  if (customProjectRoot && fs.existsSync(customProjectRoot)) return customProjectRoot;
  if (globalProjectRoot) return globalProjectRoot;
  const fallback = path.resolve(__dirname, '../../../../../..');
  logger.error('Project root not set, using fallback', { fallback });
  return fallback;
}
```

## 3. パス検証 (`validatePath`)
### 3.1 処理手順
1. `getRepoRoot()` でリポジトリルート取得
2. 入力が絶対パスの場合
   - そのまま正規化し `target` として使用
3. 入力が相対パスの場合
   - `path.normalize` → `path.resolve(repoRoot, normalized)` で絶対パス化
   - `..` を含む場合は即座に拒否
4. `path.relative(repoRoot, target)` が `..` で始まる場合はリポジトリ外とみなす
5. 例外的ホワイトリスト
   - `context.mdc` / `context.md` の絶対パスのみ許可 (`allowedByWhitelist = true`)
6. `fs.existsSync(target)` で存在確認

### 3.2 戻り値
```ts
interface PathValidationResult {
  valid: boolean;
  repoRoot: string;
  normalized: string;
  target: string;
  error?: string;
  isInsideRepo?: boolean;
  allowedByWhitelist?: boolean;
}
```
- 検証失敗時は `valid=false` と `error` を含める
- 検証成功時は `target` にアクセス可能な絶対パスを格納

### 3.3 ログ戦略
- 失敗時: `logger.warn('パスがリポジトリ外', {...})`
- ホワイトリスト許可時: `logger.info('Absolute path allowed by whitelist', {...})`
- 存在しないファイル: `logger.warn('File does not exist', {...})`
- 例外発生時: `logger.error('パス検証中にエラーが発生', {...})`

## 4. IPCハンドラーラップ (`withPathValidation`)
`withPathValidation` は IPCハンドラーにパス検証を付与します。

```ts
ipcMain.handle('docs:read', withPathValidation(async (_event, validation) => {
  const text = await fs.promises.readFile(validation.target, 'utf8');
  return { success: true, content: text };
}));
```

- `validation.valid === false` の場合 `createSecurityError()` をスロー
- 呼び出し元は try/catch で `{ success: false, error }` を返却
- 監査用に `PathValidationResult` 全体をエラーログへ出力

## 5. Settings連携
- `ipcMain.handle('settings:setProjectRoot')`
  - Rendererから渡されたパスを `setCustomProjectRoot` へ渡す
  - 成功時は `window.rulesWatcher.setContextPath()` を利用しQuality Gatesに反映
- `ipcMain.handle('settings:getProjectRoot')`
  - カスタム設定があれば優先して返却
  - 返却値 `{ root: string }`
- AIプロバイダー選択 (`settings:setAiProvider`) もMainで永続化し、セキュアにRendererへ戻す

## 6. 例外許容ポリシー
| ケース | 条件 | 理由 |
|--------|------|------|
| `context.mdc`/`context.md` の絶対パス | ファイル名が一致・実際に存在 | ドキュメント閲覧用にリポジトリ外のContextを許容 |
| それ以外の絶対パス | 常に拒否 | 任意ファイル読み込みを防止 |

- ホワイトリスト許可時も `allowedByWhitelist=true` を設定し監査可能にする

## 7. Renderer防御策
- Preloadで公開するAPIのみ利用可能 (`window.docs`, `window.tasks`, `window.rulesWatcher`, `window.settings`)
- Rendererは直接ファイルパスを扱わず、常に相対パスをIPCへ渡す
- `window.dialog.selectContextFile()` で取得した絶対パスは `rules:setContext` へ渡す前に `setContextPath()` が再度検証

## 8. 監査・テレメトリ
- `logger` はすべて構造化オブジェクトを出力 (JSONとして集計可能)
- 重要イベント
  - `Global project root set`
  - `Custom project root set`
  - `Absolute path allowed by whitelist`
  - `Path validation failed`
- 監査ログの保存先は標準出力（プロセスマネージャ側で集約）

## 9. 関連文書
- [IPC設計.mdc](IPC設計.mdc)
- [QualityGatesパイプライン詳細設計.mdc](../QA/QualityGatesパイプライン詳細設計.mdc)
- [Rendererドメインサービス設計.mdc](../DEVELOPMENT/Rendererドメインサービス設計.mdc)
